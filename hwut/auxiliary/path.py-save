import sys
import os
import stat
import binascii

import hwut.io.messages as io
import hwut.common      as common
from   hwut.common      import __safe_path as __safe_path


def strip_dot_slash(Filename):
    if len(Filename) > 2 and Filename[:2] == "./": return Filename[2:]
    else:                                          return Filename

def ensure_dot_slash(Filename):
    if len(Filename) > 2 and Filename[:2] != "./": return "./" + Filename
    else:                                          return Filename

def get_protocol_file_name(Entry, Choice, OutputF=False):
    """Get the name of the protocol file that corresponds to a test application 
       and a specific choice. The protocol file name in the output directory **does**
       contain always the choice. In the GOOD directory, it is possible that
       all choices produce the **same** output. Then, the protocol file name does not
       contain the choice.
    """
    safe_choice = Choice.replace("/", "-slash-")
    safe_choice = safe_choice.replace("\\", "-backslash-")
    safe_choice = safe_choice.replace(":", "-colon-")
    safe_choice = safe_choice.replace("#", "-hash-")
    safe_choice = safe_choice.replace(";", "-semi-colon-")
    safe_choice = safe_choice.replace(" ", "-space-")
    safe_choice = safe_choice.replace("\t", "-tabulator-")
    safe_choice = safe_choice.replace("\n", "-newline-")
    safe_choice = safe_choice.replace("\r", "-retour-")

    arg_str = ""
    if OutputF and safe_choice != "":            
        # ./OUT files differ always by choice
        arg_str = "--" + safe_choice
    elif safe_choice != "" and not Entry.all_choices_same_result_f(): 
        # ./GOOD files may be the same for all choices, see 'else:'
        arg_str = "--" + safe_choice
    else:
        # If all choices produce the same result then the GOOD files do not contain
        # the choice in the filename.
        pass

    candidate = Entry.file_name() + arg_str + ".txt"
    a_code = ord('a'); z_code = ord('z')
    A_code = ord('A'); Z_code = ord('Z')

    final = []
    for letter in candidate:
        code = ord(letter)
        if   code >= a_code and code <= z_code: final.append(letter)   # do not rely on isalpa(), since that may be local
        elif code >= A_code and code <= Z_code: final.append(letter)
        elif letter.isdigit():                  final.append(letter)
        elif letter in [".", "-", "_"]:         final.append(letter)
        else:                                   final.append("0x%2X" % code) 

    return "".join(final)

def split_path(Path):
    """Split the path according to the corresponding operating system."""
    assert type(Path) != list
    remainder = os.path.normpath(Path)
    tail      = "(empty)"
    path_chain = []
    while tail != "":
        remainder, tail = os.path.split(remainder)
        if tail != "": path_chain.append(tail)
    path_chain.append(remainder)
    path_chain.reverse()
    return path_chain

def good_path(Directory, FileName):
    """Builds a good relative path consisting of the 'Directory' and the
    'File'.
    
    RETURNS: None      -- in case of non-existing path
             Path name
    """
    path = "%s/%s" % (Directory, FileName)
    path = os.path.normpath(path)
    try:    return os.path.relpath(path)
    except: return None

def recursive_subdirectory_iterable(DirList):
    """Walks recursive along the each directory found in 'DirList'. 

    YIELDS: directory name (relative path to 'os.getcwd()')
    """
    assert type(DirList) == list
    done_set = set()
    for over_directory in DirList:
        for directory, dummy, dummy in os.walk(over_directory):
            directory = os.path.relpath(directory)
            if directory in done_set: continue
            yield directory
            done_set.add(directory)

def close_directory_iterable(FocusDir, MaxDepth=None):
    """Walks through directories close to this directory first, then it searches
    for directories in nesting directories.
    
    MaxDepth tells how many directories at max. one should go backwards.
    
    YIELDS: directory name (relative path to 'os.getcwd()')
    """
    yield os.path.relpath(FocusDir)

    path  = os.path.abspath(FocusDir)
    depth = -1
    while path and (MaxDepth is None or depth < MaxDepth): 
        depth += 1
         
        previous_path       = path
        path, sub_dir_to_me = os.path.split(path)
         
        for sub_dir in os.listdir(path):
            if sub_dir == sub_dir_to_me: continue
            directory = good_path(path, sub_dir)
            if not os.path.isdir(directory): continue
             
            for directory in recursive_subdirectory_iterable([directory]):
                yield directory
         
        
    
