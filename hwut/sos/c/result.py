# SPDX license identifier: LGPL-2.1
#
# Copyright (C) Frank-Rene Schaefer, private.
# Copyright (C) Frank-Rene Schaefer, 
#               Visteon Innovation&Technology GmbH, 
#               Kerpen, Germany.
#
# This file is part of "HWUT -- The hello worldler's unit test".
#
#                  http://hwut.sourceforge.net
#
# This file is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This file is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this file; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301 USA
#
#------------------------------------------------------------------------------
import hwut.common                  as     common
import hwut.auxiliary.path          as     path
import hwut.auxiliary.file_system   as     fs
from   hwut.sos.c.implementation_db import ImplementationDb

import os
from   copy        import copy
from   collections import namedtuple, defaultdict
from   operator    import attrgetter

ImplementationSelection = namedtuple("ImplementationSelection", 
                                     ("chosen", "remaining_list"))

def init_construction(VariableList):
    global variable_db
    variable_db.init(VariableList)

def write_makefile(MakefileName, SetupList):
    """RETURNS: True  -- oll korrekt
                False -- else.
    """
    global variable_db

    variable_db.register("TESTS", None, 
                         [s.linkage.application for s in SetupList]) 
    variable_txt = variable_db.get_definitions()

    comment_txt  = variable_db.get_origin_table_comment("OBJECTS")

    general_rule_txt = [
        "all: $(TESTS)\n\n",
        CleanRule.from_BuildSetup_list(SetupList).get_string(),
        "hwut-info:\n"
        "\t@echo $(TESTS)\n\n",
    ]
    linkage_rule_txt = [
        r.get_string() for r in flatten(s.linkage.get_rules() for s in SetupList)
    ]
    compile_rule_txt = sorted(list(set(
        r.get_string() for r in flatten(s.compilation.get_rules() for s in SetupList)
    )))

    fh = fs.open_or_die(MakefileName, "wb")
    fh.write("RM := rm\n")
    write_linker_definition(fh)
    write_compiler_definition(fh)
    fh.write("\n")
    fh.write("%s\n" % "".join(variable_txt))
    fh.write("%s\n" % "".join(comment_txt))
    fh.write("%s\n" % "".join(general_rule_txt + linkage_rule_txt + compile_rule_txt))
    fh.close()

    return True

def write_mini_makefile(MakefileName, SourceFileList, IncludePathList):

    fh = fs.open_or_die(MakefileName, "wb")
    fh.write(
         "# Mini-Makefile -- generated by 'hwut sosi' (SOS - initial)\n"
         "#\n"
         "# PURPOSE: Put the user into a initial position to start analyzing compile\n"
         "#          erros.\n"
         "#\n"
         "# The user may go step by step through the errors which are reported by\n"
         "# the compiler. Once, compilation succeeds, then 'hwut sos' or 'hwut sols'\n"
         "# may be used to generate elegant makefiles.\n"
         "#\n"
         "# NOTE: It may be necessary to add compile flags or even delete some include\n"
         "#       directories, before things compile properly.\n"
         "#____________________________________________________________________________\n\n"
    )
    fh.write("RM := rm\n")
    write_compiler_definition(fh)
    fh.write("\n")
    fh.write(    "INCLUDES := \\\n")
    if IncludePathList:
        L = max(len(path) for path in IncludePathList)
        last_i = len(IncludePathList) - 1
        for i, path in enumerate(IncludePathList):
            fh.write("            -I%s " % path)
            if i != last_i: fh.write("%s\\\n" % (" " * (L - len(path))))
            else:           fh.write("#\n")

    rule_txt      = []
    tmp_file_list = []
    for source_file in SourceFileList:
        tmp_file = "tmp-%i.o" % i
        tmp_file_list.append(tmp_file)

        rule_txt.extend([
            "%s: %s\n" % (tmp_file, source_file),
            "\t$(CC) $(INCLUDES) -c %s -o %s\n\n" % (source_file, tmp_file)
        ])

    fh.write("\n")
    fh.write("all: %s\n\n" % "".join("%s " % f for f in tmp_file_list))
    fh.write("".join(rule_txt))
    fh.write("clean:\n")
    fh.write("\t$(RM) tmp.o\n\n")
    fh.close()

def write_compiler_definition(fh):
    fh.write(
        "\n"
        "CC := gcc -c\n"
        "# Useful additional flags:\n"
        "#    -ggdb              -- gdb-debugger information embedded\n"
        "#    -Wall              -- all warnings enabled\n"
        "#    -Wimplicit         -- warn on implicit declarations\n"
        "#    -pedantic          -- be pedantic\n"
        "#    -Werror            -- raise all warnings as errors\n"
        "#    -coverage          -- for coverage analysis (lcov, gcov etc.)\n"
        "#    -std=c99           -- for C99 compliance\n"
        "#    -fno-inline        -- avoid inlining, implement seperate functions\n"
        "#    -fsanitize=address -- fast memory error detector\n"
    )

def write_linker_definition(fh):
    fh.write(
        "\n"
        "LD := gcc\n"
        "# Useful additional flags:\n"
        "#    -ggdb              -- gdb-debugger information embedded\n"
        "#    -coverage          -- for coverage analysis (lcov, gcov etc.) \n" 
        "#    -fsanitize=address -- fast memory error detector\n"
    )

def write_fly(SetupList):
    """
    link: {
        name:      application.exe;
        flags:     [ ]
        libraries: [ ] 
        libdirs:   [ ]

        compile: {
            sources: [ ]
            flags:   [ ]
            include_db: [
                [ source_dir; include_dir_list; ]
            ]
        }

    }
    """
    return
    make_info_fly = common.HWUT_FILE_MAKEFILE_FLY



class IndexDb:
    def __init__(self):
        self._db = {}

    def get(self, Value):
        index = self._db.get(Value)
        if index is None:
            index = len(self._db)
            self._db[Value] = index
        return index

    def get_name_extension(self, Name, Suffix=None):
        index = self.get(Name)
        assert index is not None

        if Suffix:  return "_%i%s" % (index, Suffix)
        else:       return "_%i"   % index

            
directory_index_db   = IndexDb()  
application_index_db = IndexDb()

class ObjectFileDb:
    def __init__(self):
        self._basename_db = {}  # basename --> first source file with that base
        self._db          = {}
        # Set of directories that contain source files with more than
        # one same base name. The directories in the set are the once
        # that contain an 'indexed' source file--not the first with the
        # same basename.
        self._indexed_set = set()

    def prepare(self, SourceFileList):
        for s in SourceFileList: 
            self.__enter(s)

    def register_object_file(self, ObjectFile):
        self._db["<raw object filei %i>" % len(self._db)] = ObjectFile

    def __enter(self, SourceFile):
        object_file = self._db.get(SourceFile)
        if object_file is not None:
            return object_file

        basename = os.path.basename(SourceFile)
        if basename not in self._basename_db:
            self._basename_db[basename] = SourceFile
            object_file = path.replace_extension(basename, ".o")
        else:
            prev_source_file           = self._basename_db[basename]
            self._db[prev_source_file] = self.unique_object_file_name(prev_source_file)

            object_file = self.unique_object_file_name(SourceFile)

        self._db[SourceFile] = object_file

    def get_object_file_list(self, SourceFileList):
        for s in SourceFileList:
            assert s in self._db
        return [ self._db[s] for s in sorted(SourceFileList) if s in self._db ]

    def indexed_source_directories(self, SubSet=None):
        if SubSet is None:
            return self._indexed_set
        else:
            return self._indexed_set.intersection(SubSet)

    def unique_object_file_name(self, SourceFile):
        basename  = os.path.basename(SourceFile)
        directory = os.path.dirname(SourceFile)
        new_tail  = "%s.o" % directory_index_db.get_name_extension(directory)
        self._indexed_set.add(directory)
        return path.replace_extension(basename, new_tail)

    def get_inverse_db(self):
        return dict(
            (object_file, source_file)
            for source_file, object_file in self._db.iteritems()
        )

object_file_db = ObjectFileDb()

class VariableDb:
    """A Makefile Variable.

    A variable is assigned with a list of strings. There are four types of 
    variables: INCLUDES, LIBRARIES, LIBDIRS, and OBJECTS. A specific variable
    name is a concatenation of the variable type and a suffix. For example
    'OBJECTS_1' is the first collection of objects. 

    This class determines automatically names that appear in the same variable
    type. This way, common elements can be defined in a central location. 
    Particular variables can then refer to the global variable.
    """
    __slots__ = ("common_db", "db", "origin_db", "name_db")

    def __init__(self):
        self.common_db = None
        self.db        = None
        self.origin_db = None
        self.name_db   = None

    def init(self, TypeStringList):
        # map: variable name --> common value list
        #
        self.common_db = dict(
            (ts, None) for ts in TypeStringList
        )
        self.common_db["TESTS"] = set()

        # map: type string --> map: 'key' --> Variable
        #
        # 'key' = source directory for 'INCLUDES', application name for 
        # 'OBJECTS'.
        self.db = dict(
            (ts, defaultdict(set)) for ts in TypeStringList
        )

        # map: type string --> origin_db
        self.origin_db = dict(
            (ts, None) for ts in TypeStringList
        )

        # map: type string --> map: 'key' --> name 
        self.name_db = dict(
            (ts, dict()) for ts in TypeStringList
        )

    def register(self, TypeString, Key, ValueList, OriginDb=None):
        """TypeString = on of the keys in 'common_db'
           Key        = SourceDir for 'INCLUDES'
                        Application for 'OBJECTS', etc.
           OriginDb: maps value from ValueList to its origin.
                     (example 'object file' to source file)
        """
        assert TypeString in self.common_db

        if Key is not None:
            self.db[TypeString][Key].update(ValueList)
            self.__common_db_adapt(TypeString, ValueList)
        else:
            self.common_db[TypeString].update(ValueList)
        
        if OriginDb is not None:
            origin_db = self.origin_db.get(TypeString)
            if origin_db is not None:
                self.origin_db[TypeString].update(copy(OriginDb))
            else:
                self.origin_db[TypeString] = copy(OriginDb)

    def get_reference(self, TypeString, Key):
        """RETURNS: Reference to access content of this variable.

        If all values are common, then there is no special implementation
        of the variable => returns the 'common' name.

        If there are values specific to this variable, not present in 
        the common => returns the specific variable name.
        """
        if not self.db[TypeString][Key]: return ""

        common_value_list, \
        special_list       = self.__get_composition(TypeString, Key)

        if not special_list: Key = None
        return "$(%s)" % self.__get_name(TypeString, Key)

    def get_definitions(self):
        """RETURNS: A String with the definition of all variables. 
        """
        def_list = [
            self.__get_definition("TESTS", None, None)
        ]

        for type_string in self.common_db:
            if type_string == "TESTS": continue
            def_list.append(
                self.__get_definition(type_string, None, self.origin_db.get(type_string))
            )
            def_list.extend(
                self.__get_definition(type_string, key, self.origin_db.get(type_string))
                for key in self.db[type_string].iterkeys()
            )

        return self.__definitions_text([ x for x in def_list if x is not None ])

    def get_origin_table_comment(self, TypeString):
        if TypeString not in self.db or TypeString not in self.origin_db:
            return ""

        def get_line(Lo, Lr, Origin, Result, PrevDirectory):
            assert Origin is not None
            r_space = " " * (Lr - len(Result)) 
                
            directory = os.path.dirname(Origin)
            if directory != PrevDirectory or not directory: 
                o_txt = Origin
            else:
                d_space = " " * max(0, len(directory)-1)
                o_txt   = "%s*/%s" % (d_space, os.path.basename(Origin))

            o_space = " " * (Lo - len(Origin))
            txt     = "#  %s%s => %s\n" % (o_txt, o_space, Result)

            return directory, txt

        value_list = []
        for key in self.db[TypeString]:
            value_list.extend(self.db[TypeString][key])

        origin_db  = self.origin_db[TypeString]
        origin_vs_result_pairs = [ 
            (origin_db[f], f) for f in value_list
        ]
        Lo = my_max([len(o) for o, r in origin_vs_result_pairs if o is not None])
        Lr = my_max([len(r) for o, r in origin_vs_result_pairs])

        txt = [
            "\n# Source to Object Relations __________________________________________________\n#\n"
        ]
        prev_directory = None
        for origin, result in sorted(set(origin_vs_result_pairs), reverse=True):
            prev_directory, line_txt = get_line(Lo, Lr, origin, result, prev_directory)
            txt.append(line_txt)
        txt.append(
            "#______________________________________________________________________________\n#\n"
        )

        return txt

    def get_union_of_uncommon(self, TypeString):
        common = self.common_db[TypeString]
        result = set()
        for value_list in self.db[TypeString].itervalues():
            result.update(value_list)

        if common is not None: return result.difference(common)
        else:                  return result

    def __common_db_adapt(self, TypeString, ValueList):
        if self.common_db[TypeString] is None:
            self.common_db[TypeString] = list(ValueList)
        elif ValueList:
            common_value_list = self.common_db[TypeString]
            L = len(common_value_list)
            for i in xrange(L-1, -1, -1):
                if common_value_list[i] not in ValueList: 
                    del common_value_list[i]

    def __get_composition(self, TypeString, Key):
        """RETURNS: [0] Values of '(TypeString, Key)' that are globally common.
                    [1] Values of '(TypeString, Key)' which are specific.
        """
        common  = self.common_db[TypeString]
        special = list(set(self.db[TypeString][Key]).difference(common))

        return common, special

    def __get_definition(self, TypeString, Key, OriginDb):

        if Key is None: 
            # Common variable
            value_list = self.common_db[TypeString]
            if not value_list: return (TypeString, [])
        else:
            # This is not a common variable.
            common_value_list, \
            special_value_list = self.__get_composition(TypeString, Key)
            if not special_value_list: return None
            value_list = ["$(%s)" % TypeString ] + special_value_list
               
        name = self.__get_name(TypeString, Key)

        return name, [value.strip() for value in value_list]

    def __get_name(self, TypeString, Key):
        if Key is None:
            return TypeString
        value_tuple = tuple(sorted(self.db[TypeString][Key]))

        name = self.name_db[TypeString].get(value_tuple)
        if name is not None: return name

        name = "%s_%s" % (TypeString, len(self.name_db[TypeString]))
        self.name_db[TypeString][value_tuple] = name
        return name

    def __definitions_text(self, DefinitionList):
        """DefinitionList = list of pairs (name, row list)
        """

        def terminate(txt, Row, LastF):
            if not LastF:
                txt.append("%s\\\n" % (" " * (Lr - len(Row))))
            else:
                txt.append(" #\n")

        txt    = []
        Ln     = my_max([len(x[0]) for x in DefinitionList])
        Lr     = my_max([len(row) for row in flatten(x[1] for x in DefinitionList)]) + 2

        indent = " " * (Ln + 4)
        for name, row_list in DefinitionList: 
            name_length = len(name)
            txt.append("%s%s := " % (name, " " * (Ln - name_length)))
            row_list = [row for row in row_list if row.strip()]
            if not row_list: 
                txt.append(" #\n")
            else:
                row_n        = len(row_list)
                row_iterable = iter(row_list)
                row          = row_iterable.next()
                i            = 1
                txt.append("%s" % row)
                terminate(txt, row, i == row_n)
                for row in row_iterable:
                    i += 1
                    txt.append("%s%s" % (indent, row))
                    terminate(txt, row, i == row_n)

        return "".join(txt)



variable_db = VariableDb()

class SetupBase:
    def __init__(self):
        pass

class SetupBuild:

    def __init__(self, Compilation, Linkage):
        self.compilation  = Compilation
        self.linkage      = Linkage

    @staticmethod
    def from_analysis(ApplicationName, assembler, R):
        CompileFlags     = assembler.compiler.flag_list
        IncludeDirDb     = assembler.compiler.include_dir_db
        LibraryDirList   = assembler.linker.library_dir_db.get_directories()
        LinkFlags        = assembler.linker.flag_list

        object_file_list = SetupBuild.__prepare_object_file_list(R.object_file_list, 
                                                                 R.source_file_list)

        compilation      = SetupCompilation(R.source_file_list, IncludeDirDb, 
                                            CompileFlags) 
                         
        linkage          = SetupLinkage(ApplicationName, object_file_list, 
                                        R.library_file_list, LibraryDirList, LinkFlags)

        return SetupBuild(compilation, linkage)

    @staticmethod
    def from_fly(fh):
        compilation = SetupCompilation.from_fly(fh)
        linkage     = SetupLinkage.from_fly(fh)
        return SetupBuild(compilation, linkage)

    def to_fly(self, fh):
        self.compilation.to_fly(fh)
        self.linkage.to_fly(fh)

    def get_rules(self):
        """RETURNS: list of Rule objects (CompileRule, LinkRule).
        """
        def sort_key(R):
            return (R._dependencies(0), R._target())

        return   sorted(self.linkage.get_rules(), key=sort_key) \
               + sorted(self.compilation.get_rules(), key=sort_key)

    @staticmethod
    def __prepare_object_file_list(ObjectFileList, SourceFileList):
        global object_file_db

        result = object_file_db.get_object_file_list(SourceFileList)
        result.extend(ObjectFileList)

        # Delete double occurences
        i = len(result)
        while i > 0:
            i -= 1
            x = result[i]
            if result.count(x) != 1: del result[i]

        return result


class SetupCompilation(SetupBase):
    def __init__(self, SourceFileSet, SourceToIncludeDirDb, CompileFlags):
        global variable_db

        self.flag_list               = CompileFlags
        source_dir_to_include_dir_db = SourceToIncludeDirDb.get_include_dir_by_source_dir(SourceFileSet)

        # map: source_dir --> include variable
        for source_dir, include_dir_list in source_dir_to_include_dir_db.iteritems():
             variable_db.register("INCLUDES", source_dir, 
                                  prefix_list("-I", include_dir_list))

        self.source_dir_set = set(
            os.path.dirname(s) for s in SourceFileSet
        )

    @staticmethod
    def from_fly(fh):
        pass

    def to_fly(self, fh):
        pass
       
    def get_rules(self):
        """RETURNS: list of CompileRule objects.
        """
        global object_file_db
        global variable_db

        # Rules for files with ambiguous base names.
        rules = [
            CompileRule("%%%s.o" % directory_index_db.get_name_extension(source_dir),
                        source_dir, self.flag_list, 
                        variable_db.get_reference("INCLUDES", source_dir))
            for source_dir in object_file_db.indexed_source_directories(self.source_dir_set)
        ]

        # Rules for files with unique base names.
        rules.extend(
            CompileRule("%.o", source_dir, self.flag_list, 
                        variable_db.get_reference("INCLUDES", source_dir))
            for source_dir in self.source_dir_set
        )

        return rules

class SetupLinkage(SetupBase):
    def __init__(self, Application, ObjectFileList, LibraryFileList, LibDirList, LinkFlags):
        global object_file_db
        global variable_db
        self.application         = Application
        self.flag_list = LinkFlags

        variable_db.register("OBJECTS",   Application,  ObjectFileList, 
                             OriginDb = object_file_db.get_inverse_db())
        variable_db.register("LIBRARIES", Application, LibraryFileList) 
        variable_db.register("LIBDIRS",   Application, prefix_list("-L%", LibDirList))

    @staticmethod
    def from_fly(fh):
        """Grammar:
                      build: {
                          pattern:   NAME_PATTERN;
                          objects:   [ OBJECTS ]
                          libraries: [ LIBRARIES ]
                          lib_dirs:  [ LIBDIRS ]
                          flags:     FLAGS; 
                      }
        """
        pass
       
    def to_fly(self, fh):
        pass

    def get_rules(self):
        return [
            LinkRule(self.application, self.flag_list, 
                     variable_db.get_reference("OBJECTS", self.application),
                     variable_db.get_reference("LIBRARIES", self.application),
                     variable_db.get_reference("LIBDIRS", self.application))
        ]

class Rule:
    def get_string(self):
        target_str     = self._target()
        dependency_str = self._dependencies(len(target_str) + 2)
        action_str     = self._action()
        return   "%s: %s\n" % (target_str, dependency_str) \
               + "%s\n\n"   % action_str 

    @staticmethod
    def get_flag_string(FlagList):
        return "".join(" %s" % x for x in FlagList).strip()


class CompileRule(Rule):
    def __init__(self, ObjectFilePattern, SourceDir, UserCompileFlagList, IncludeVarRef):
        self.object_file_pattern  = ObjectFilePattern
        self.flag_list            = copy(UserCompileFlagList)
        self.source_dir           = SourceDir
        self.include_var_ref      = IncludeVarRef

    def _target(self):
        return self.object_file_pattern

    def _dependencies(self, ColumnIndex):
        if self.source_dir: return "%s/%%.c" % self.source_dir.replace("\\", "/")
        else:               return "%.c"

    def _action(self):
        flag_str        = Rule.get_flag_string(self.flag_list)

        flag_str = "%s %s" % (flag_str, self.include_var_ref)

        return "\t$(CC) %s $< -o $@" % flag_str.strip()


class LinkRule(Rule):
    def __init__(self, Application, UserLinkFlagList, ObjectsVarRef, LibrariesVarRef, LibdirsVarRef):
        self.application_pattern = Application

        self.flag_list         = copy(UserLinkFlagList)
        self.objects_var_ref   = ObjectsVarRef
        self.libraries_var_ref = LibrariesVarRef
        self.libdirs_var_ref   = LibdirsVarRef

    def _target(self):
        return self.application_pattern

    def _dependencies(self, ColumnIndex):
        return "%s %s" % (self.objects_var_ref, self.libraries_var_ref) 

    def _action(self):
        flag_str  = Rule.get_flag_string(self.flag_list)
        flag_str += " %s" % self.objects_var_ref
        flag_str += " %s" % self.libdirs_var_ref
        flag_str += " %s" % self.libraries_var_ref

        return "\t$(LD) %s -o $@" % flag_str.strip()

class CleanRule(Rule):
    def __init__(self):
        self.object_file_set  = set()

    @staticmethod
    def from_BuildSetup_list(SetupList):
        global variable_db
        result = CleanRule()
        result.object_file_set = variable_db.get_union_of_uncommon("OBJECTS")
        return result

    def _target(self):
        return "clean"

    def _dependencies(self, ColumnIndex):
        return ""

    def _action(self):
        txt = [ 
            "$(RM) -f $(TESTS)\n",
            "$(RM) -f $(OBJECTS)\n",
            "$(RM) -f %s\n" % "".join("%s " % f for f in sorted(self.object_file_set) if f)
        ]
        txt.append(
            "# OPTIONAL: $(RM) -f *~ *.bak *.info *.orig core stackdump *.tmp tmp.* *.gc*\n"
        )
        return "".join("\t%s" % action for action in txt)

class HwutGeneratorRule:
    def __init__(self, Cmd, InputFile, OutputFileStem, Flags):
        self.command          = Cmd
        self.input_file       = InputFile
        self.output_file_stem = OutputFileStem
        self.flags            = Flags

    def _target(self):
        return "%s.o" % OutputFileStem

    def _dependencies(self, ColumnIndex):
        return "%s" % self.input_file

    def _action(self):
        return "hwut %s %s -o %s.o %s" % (self.command, self.input_file, self.output_file_stem, self.flags)

def prefix_list(Prefix, StrList):
    return  ["%s%s " % (Prefix, s.replace("\\", "/")) for s in sorted(StrList)]

def flatten(ListOfLists):
    return [x for sublist in ListOfLists for x in sublist]

def my_max(List):
    if not List: return 0
    else:        return max(List)


